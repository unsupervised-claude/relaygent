#!/bin/bash
# PostToolUse hook: sandbox external message content from MCP tools
# Reads hook JSON from stdin, wraps matching tool responses with sandbox delimiters.

INPUT=$(cat)
TOOL_NAME=$(printf '%s' "$INPUT" | jq -r '.tool_name // empty')

# Only process tools that return external human content
case "$TOOL_NAME" in
    mcp__comms__read|mcp__comms__unread|\
mcp__comms__read_email|mcp__comms__search_emails|\
mcp__comms__phone_call_listen|mcp__comms__phone_call_converse|mcp__comms__phone_call_auto_transcript)
        ;;
    *)
        exit 0
        ;;
esac

# Extract the source label from tool name
case "$TOOL_NAME" in
    mcp__comms__read_email|mcp__comms__search_emails) SOURCE="Gmail" ;;
    mcp__comms__phone_call_*) SOURCE="PhoneCall" ;;
    mcp__comms__*) SOURCE="Comms" ;;
    *) SOURCE="external" ;;
esac

# Extract the text content from tool_response.content[].text
RESPONSE_TEXT=$(printf '%s' "$INPUT" | jq -r '[.tool_response.content[]? | select(.type == "text") | .text] | join("\n")' 2>/dev/null)

if [ -z "$RESPONSE_TEXT" ]; then
    exit 0
fi

# Sandbox the content using sibling script
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SANDBOXED=$(printf '%s' "$RESPONSE_TEXT" | "$SCRIPT_DIR/sandbox-content" "$SOURCE")

jq -n --arg content "$SANDBOXED" '{
    "hookSpecificOutput": {
        "hookEventName": "PostToolUse",
        "updatedMCPToolOutput": $content
    }
}'
